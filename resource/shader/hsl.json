{
  type: FRAGMENT,
  source: [
    "#version 130\n",
    "//based on http://www.chilliant.com/rgb2hsv.html\n",

    "const float Epsilon = 1e-10;\n",

    "vec3 HUE2RGB(float hue) {\n",
    "    return clamp(vec3(\n",
    "                 abs(hue * 6 - 3) - 1,\n",
    "                 2 - abs(hue * 6 - 2),\n",
    "                 2 - abs(hue * 6 - 4)\n",
    "                 ),\n",
    "                 0,\n",
    "                 1);\n",
    "}\n",

    "vec3 RGB2HCV(vec3 RGBColor) {\n",
    "   vec4 P = (RGBColor.g < RGBColor.b) ? \n",
    "   vec4(RGBColor.bg, -1.0, 2.0/3.0) : \n",
    "   vec4(RGBColor.gb, 0.0, -1.0/3.0); \n",

    "   vec4 Q = (RGBColor.r < P.x) ? vec4(P.xyw, RGBColor.r) : vec4(RGBColor.r, P.yzx);\n",
    "   float C = Q.x - min(Q.w, Q.y);\n",
    "   float H = abs((Q.w - Q.y) / (6 * C + Epsilon) + Q.z);\n",
    "   return vec3(H, C, Q.x);\n",
    "}\n",

    "vec3 HSL2RGB(vec3 HSLColor) {\n",
    "   vec3 RGBColor = HUE2RGB(HSLColor.x);\n",
    "    float C = (1 - abs(2 * HSLColor.z - 1)) * HSLColor.y;\n",
    "    return (RGBColor - 0.5) * C + HSLColor.z;\n",
    "}\n",

    "vec3 RGB2HSL(vec3 RGBColor) {\n",
    "    vec3 HCVColor    = RGB2HCV(RGBColor);\n",
    "    float L  = HCVColor.z - HCVColor.y * 0.5;\n",
    "    float Saturation = HCVColor.y / (1 - abs(L * 2 - 1) + Epsilon);\n",
    "    return vec3(HCVColor.x, Saturation, L);\n",
    "}\n",
  ]
}

