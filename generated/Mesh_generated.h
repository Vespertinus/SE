// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MESH_SE_FLATBUFFERS_H_
#define FLATBUFFERS_GENERATED_MESH_SE_FLATBUFFERS_H_

#include "flatbuffers/flatbuffers.h"

namespace SE {
namespace FlatBuffers {

struct Vec3;

struct Vec2;

struct ColorARGB;

struct Shape;

struct Mesh;

MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vec3() {
    memset(this, 0, sizeof(Vec3));
  }
  Vec3(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
STRUCT_END(Vec3, 12);

MANUALLY_ALIGNED_STRUCT(4) Vec2 FLATBUFFERS_FINAL_CLASS {
 private:
  float u_;
  float v_;

 public:
  Vec2() {
    memset(this, 0, sizeof(Vec2));
  }
  Vec2(float _u, float _v)
      : u_(flatbuffers::EndianScalar(_u)),
        v_(flatbuffers::EndianScalar(_v)) {
  }
  float u() const {
    return flatbuffers::EndianScalar(u_);
  }
  float v() const {
    return flatbuffers::EndianScalar(v_);
  }
};
STRUCT_END(Vec2, 8);

MANUALLY_ALIGNED_STRUCT(4) ColorARGB FLATBUFFERS_FINAL_CLASS {
 private:
  float a_;
  float r_;
  float g_;
  float b_;

 public:
  ColorARGB() {
    memset(this, 0, sizeof(ColorARGB));
  }
  ColorARGB(float _a, float _r, float _g, float _b)
      : a_(flatbuffers::EndianScalar(_a)),
        r_(flatbuffers::EndianScalar(_r)),
        g_(flatbuffers::EndianScalar(_g)),
        b_(flatbuffers::EndianScalar(_b)) {
  }
  float a() const {
    return flatbuffers::EndianScalar(a_);
  }
  float r() const {
    return flatbuffers::EndianScalar(r_);
  }
  float g() const {
    return flatbuffers::EndianScalar(g_);
  }
  float b() const {
    return flatbuffers::EndianScalar(b_);
  }
};
STRUCT_END(ColorARGB, 16);

struct Shape FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_VERTICES = 6,
    VT_TRIANGLES_CNT = 8,
    VT_TEXTURE = 10,
    VT_MIN = 12,
    VT_MAX = 14
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  ///pos 3 float, normal 3 float, uv 2 float, or pos and uv
  const flatbuffers::Vector<float> *vertices() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_VERTICES);
  }
  uint32_t triangles_cnt() const {
    return GetField<uint32_t>(VT_TRIANGLES_CNT, 0);
  }
  const flatbuffers::String *texture() const {
    return GetPointer<const flatbuffers::String *>(VT_TEXTURE);
  }
  const Vec3 *min() const {
    return GetStruct<const Vec3 *>(VT_MIN);
  }
  const Vec3 *max() const {
    return GetStruct<const Vec3 *>(VT_MAX);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyOffsetRequired(verifier, VT_VERTICES) &&
           verifier.Verify(vertices()) &&
           VerifyField<uint32_t>(verifier, VT_TRIANGLES_CNT) &&
           VerifyOffset(verifier, VT_TEXTURE) &&
           verifier.Verify(texture()) &&
           VerifyFieldRequired<Vec3>(verifier, VT_MIN) &&
           VerifyFieldRequired<Vec3>(verifier, VT_MAX) &&
           verifier.EndTable();
  }
};

struct ShapeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Shape::VT_NAME, name);
  }
  void add_vertices(flatbuffers::Offset<flatbuffers::Vector<float>> vertices) {
    fbb_.AddOffset(Shape::VT_VERTICES, vertices);
  }
  void add_triangles_cnt(uint32_t triangles_cnt) {
    fbb_.AddElement<uint32_t>(Shape::VT_TRIANGLES_CNT, triangles_cnt, 0);
  }
  void add_texture(flatbuffers::Offset<flatbuffers::String> texture) {
    fbb_.AddOffset(Shape::VT_TEXTURE, texture);
  }
  void add_min(const Vec3 *min) {
    fbb_.AddStruct(Shape::VT_MIN, min);
  }
  void add_max(const Vec3 *max) {
    fbb_.AddStruct(Shape::VT_MAX, max);
  }
  explicit ShapeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShapeBuilder &operator=(const ShapeBuilder &);
  flatbuffers::Offset<Shape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Shape>(end);
    fbb_.Required(o, Shape::VT_VERTICES);
    fbb_.Required(o, Shape::VT_MIN);
    fbb_.Required(o, Shape::VT_MAX);
    return o;
  }
};

inline flatbuffers::Offset<Shape> CreateShape(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> vertices = 0,
    uint32_t triangles_cnt = 0,
    flatbuffers::Offset<flatbuffers::String> texture = 0,
    const Vec3 *min = 0,
    const Vec3 *max = 0) {
  ShapeBuilder builder_(_fbb);
  builder_.add_max(max);
  builder_.add_min(min);
  builder_.add_texture(texture);
  builder_.add_triangles_cnt(triangles_cnt);
  builder_.add_vertices(vertices);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Shape> CreateShapeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<float> *vertices = nullptr,
    uint32_t triangles_cnt = 0,
    const char *texture = nullptr,
    const Vec3 *min = 0,
    const Vec3 *max = 0) {
  return SE::FlatBuffers::CreateShape(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      vertices ? _fbb.CreateVector<float>(*vertices) : 0,
      triangles_cnt,
      texture ? _fbb.CreateString(texture) : 0,
      min,
      max);
}

struct Mesh FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SHAPES = 4,
    VT_MIN = 6,
    VT_MAX = 8,
    VT_SKIP_NORMALS = 10
  };
  const flatbuffers::Vector<flatbuffers::Offset<Shape>> *shapes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Shape>> *>(VT_SHAPES);
  }
  const Vec3 *min() const {
    return GetStruct<const Vec3 *>(VT_MIN);
  }
  const Vec3 *max() const {
    return GetStruct<const Vec3 *>(VT_MAX);
  }
  bool skip_normals() const {
    return GetField<uint8_t>(VT_SKIP_NORMALS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_SHAPES) &&
           verifier.Verify(shapes()) &&
           verifier.VerifyVectorOfTables(shapes()) &&
           VerifyFieldRequired<Vec3>(verifier, VT_MIN) &&
           VerifyFieldRequired<Vec3>(verifier, VT_MAX) &&
           VerifyField<uint8_t>(verifier, VT_SKIP_NORMALS) &&
           verifier.EndTable();
  }
};

struct MeshBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_shapes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Shape>>> shapes) {
    fbb_.AddOffset(Mesh::VT_SHAPES, shapes);
  }
  void add_min(const Vec3 *min) {
    fbb_.AddStruct(Mesh::VT_MIN, min);
  }
  void add_max(const Vec3 *max) {
    fbb_.AddStruct(Mesh::VT_MAX, max);
  }
  void add_skip_normals(bool skip_normals) {
    fbb_.AddElement<uint8_t>(Mesh::VT_SKIP_NORMALS, static_cast<uint8_t>(skip_normals), 0);
  }
  explicit MeshBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MeshBuilder &operator=(const MeshBuilder &);
  flatbuffers::Offset<Mesh> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Mesh>(end);
    fbb_.Required(o, Mesh::VT_SHAPES);
    fbb_.Required(o, Mesh::VT_MIN);
    fbb_.Required(o, Mesh::VT_MAX);
    return o;
  }
};

inline flatbuffers::Offset<Mesh> CreateMesh(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Shape>>> shapes = 0,
    const Vec3 *min = 0,
    const Vec3 *max = 0,
    bool skip_normals = false) {
  MeshBuilder builder_(_fbb);
  builder_.add_max(max);
  builder_.add_min(min);
  builder_.add_shapes(shapes);
  builder_.add_skip_normals(skip_normals);
  return builder_.Finish();
}

inline flatbuffers::Offset<Mesh> CreateMeshDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Shape>> *shapes = nullptr,
    const Vec3 *min = 0,
    const Vec3 *max = 0,
    bool skip_normals = false) {
  return SE::FlatBuffers::CreateMesh(
      _fbb,
      shapes ? _fbb.CreateVector<flatbuffers::Offset<Shape>>(*shapes) : 0,
      min,
      max,
      skip_normals);
}

inline const SE::FlatBuffers::Mesh *GetMesh(const void *buf) {
  return flatbuffers::GetRoot<SE::FlatBuffers::Mesh>(buf);
}

inline const char *MeshIdentifier() {
  return "SEMS";
}

inline bool MeshBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, MeshIdentifier());
}

inline bool VerifyMeshBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<SE::FlatBuffers::Mesh>(MeshIdentifier());
}

inline const char *MeshExtension() {
  return "sems";
}

inline void FinishMeshBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<SE::FlatBuffers::Mesh> root) {
  fbb.Finish(root, MeshIdentifier());
}

}  // namespace FlatBuffers
}  // namespace SE

#endif  // FLATBUFFERS_GENERATED_MESH_SE_FLATBUFFERS_H_
